package com.github.nullsafe;

import com.github.nullsafe.result.Result;
import com.github.nullsafe.adapters.NullSafeAdapter;
import java.io.Serial;
import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * A class that encapsulates an optional value (can be null) and provides
 * methods to manipulate it safely.
 *
 * @param <T> the type of the contained value
 */
public class NullSafe<T> implements Serializable {

    private static final long serialVersionUID = 1L;

    private final T value;

    private NullSafe(T value) {
        this.value = value;
    }

    /**
     * Creates a NullSafe instance containing the specified value.
     *
     * @param value the value to encapsulate (can be null)
     * @param <T> the type of the value
     * @return a new NullSafe instance
     */
    public static <T> NullSafe<T> of(T value) {
        return new NullSafe<>(value);
    }

    /**
     * Creates an empty NullSafe instance containing null.
     *
     * @param <T> the type of the value
     * @return a new empty instance
     */
    public static <T> NullSafe<T> empty() {
        return new NullSafe<>(null);
    }

    /**
     * Returns the contained value if not null, or the given default value.
     *
     * @param defaultValue the default value to return if the value is null
     * @return the contained value or the default value
     */
    public T orElse(T defaultValue) {
        return value != null ? value : defaultValue;
    }

    /**
     * Returns the contained value if not null, or the result of executing the
     * given supplier.
     *
     * @param defaultValue the supplier of the default value
     * @return the contained value or the value generated by the supplier
     */
    public T orElseGet(Supplier<? extends T> defaultValue) {
        return value != null ? value : defaultValue.get();
    }

    /**
     * Returns the contained value if not null, or throws the generated exception.
     *
     * @param exception the supplier of the exception to throw
     * @param <E> the type of the exception
     * @return the contained value
     * @throws E if the value is null
     */
    public <E extends Exception> T orElseThrow(Supplier<? extends E> exception) throws E {
        if (value == null) {
            throw exception.get();
        }
        return value;
    }

    /**
     * Executes the given action if the value is present (not null).
     *
     * @param action the action to execute
     * @return this instance for chaining
     */
    public NullSafe<T> ifPresent(Consumer<? super T> action) {
        if (value != null) {
            action.accept(value);
        }
        return this;
    }

    /**
     * Executes the given action if the value is NOT present (is null).
     *
     * @param action the action to execute
     * @return this instance for chaining
     */
    public NullSafe<T> ifAbsent(Runnable action) {
        if (value == null) {
            action.run();
        }
        return this;
    }

    /**
     * Applies the function to the contained value, if not null, and returns a new
     * NullSafe with the result.
     *
     * @param function the function to apply
     * @param <R> the type of the result
     * @return a new NullSafe with the result or empty if the value is null
     */
    public <R> NullSafe<R> map(Function<? super T, ? extends R> function) {
        return value != null ? NullSafe.of(function.apply(value)) : NullSafe.empty();
    }

    /**
     * Applies the mapper to the contained value, if not null, and returns the
     * result.
     *
     * @param mapper the function that returns another NullSafe
     * @param <R> the type of the result
     * @return the result of the mapper or an empty NullSafe
     */
    public <R> NullSafe<R> flatMap(Function<? super T, NullSafe<R>> mapper) {
        return value != null ? mapper.apply(value) : NullSafe.empty();
    }

    /**
     * Filters the contained value using the given predicate.
     *
     * @param predicate the predicate to evaluate the value
     * @return este mismo objeto si pasa el filtro, o uno vacío en caso
     * contrario
     */
    public NullSafe<T> filter(Predicate<? super T> predicate) {
        if (value == null || !predicate.test(value)) {
            return NullSafe.empty();
        }
        return this;
    }

    /**
     * Verifica si hay un valor presente (no es null).
     *
     * @return true si hay un valor presente
     */
    public boolean isPresent() {
        return value != null;
    }

    /**
     * Verifica si NO hay un valor presente (es null).
     *
     * @return true si el valor es null
     */
    public boolean isEmpty() {
        return value == null;
    }

    /**
     * Obtiene el valor contenido, lanzando una excepción si es null.
     *
     * @return el valor contenido
     * @throws NoSuchElementException si el valor es null
     */
    public T get() {
        if (value == null) {
            throw new NoSuchElementException("No value present");
        }
        return value;
    }

    /**
     * Valida el valor contenido contra una condición, lanzando una excepción si
     * falla.
     *
     * @param <E>
     * @param condition la condición a validar
     * @param exception la excepción a lanzar si falla
     * @return esta instancia si la validación pasa
     * @throws E si la condición no se cumple
     */
    public <E extends RuntimeException> NullSafe<T> validate(Predicate<T> condition, Supplier<E> exception) {
        if (isPresent() && !condition.test(value)) {
            throw exception.get();
        }
        return this;
    }

    @Override
    public String toString() {
        return isPresent() ? String.format("NullSafe[%s]", value) : "NullSafe.empty";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof NullSafe<?> other)) {
            return false;
        }
        return Objects.equals(value, other.value);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(value);
    }

    // Additional methods for collections
    /**
     * Filters non-null elements from a collection.
     *
     * @param collection the collection to filter
     * @param <T> the type of the elements
     * @return a list with non-null elements
     */
    public static <T> List<T> filterNonNull(Collection<T> collection) {
        if (collection == null) {
            return Collections.emptyList();
        }
        return collection.stream()
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    /**
     * Maps and filters non-null elements from a collection.
     *
     * @param collection the collection to map
     * @param function the transformation function
     * @param <T> the original type
     * @param <R> the resulting type
     * @return a list with transformed and non-null elements
     */
    public static <T, R> List<R> mapNonNull(Collection<T> collection, Function<T, R> function) {
        if (collection == null) {
            return Collections.emptyList();
        }
        return collection.stream()
                .filter(Objects::nonNull)
                .map(function)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    // Additional methods for strings
    /**
     * Returns the given string or an empty string if null.
     *
     * @param value the string to check
     * @return the original string or "" if null
     */
    public static String emptyIfNull(String value) {
        return value != null ? value : "";
    }

    /**
     * Converts the string to uppercase if not null.
     *
     * @param value the string to convert
     * @return the string in uppercase or null if it was null
     */
    public static String toUpperCaseIfPresent(String value) {
        return value != null ? value.toUpperCase() : null;
    }

    /**
     * Converts the string to lowercase if not null.
     *
     * @param value the string to convert
     * @return the string in lowercase or null if it was null
     */
    public static String toLowerCaseIfPresent(String value) {
        return value != null ? value.toLowerCase() : null;
    }

    // Additional methods for maps
    /**
     * Filters non-null entries from a map.
     *
     * @param map el mapa a filtrar
     * @param <K> el tipo de clave
     * @param <V> el tipo de valor
     * @return un mapa solo con claves y valores no nulos
     */
    public static <K, V> Map<K, V> filterNonNullEntries(Map<K, V> map) {
        if (map == null) {
            return Collections.emptyMap();
        }
        return map.entrySet().stream()
                .filter(e -> e.getKey() != null && e.getValue() != null)
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    /**
     * Mapea los valores del mapa aplicando una función, ignorando entradas
     * nulas.
     *
     * @param map el mapa original
     * @param valueFunc la función para mapear valores
     * @param <K> el tipo de clave
     * @param <V> el tipo de valor original
     * @param <R> el tipo de valor resultante
     * @return un nuevo mapa con valores transformados
     */
    public static <K, V, R> Map<K, R> mapNonNullValues(Map<K, V> map, Function<V, R> valueFunc) {
        if (map == null) {
            return Collections.emptyMap();
        }
        return map.entrySet().stream()
                .filter(e -> e.getKey() != null && e.getValue() != null)
                .collect(Collectors.toMap(Map.Entry::getKey, e -> valueFunc.apply(e.getValue())));
    }

    /**
     * Convierte este NullSafe en un Optional.
     *
     * @return un Optional conteniendo el valor o vacío
     */
    public Optional<T> toOptional() {
        return Optional.ofNullable(value);
    }

    /**
     * Crea una instancia de NullSafe a partir de un Optional.
     *
     * @param optional el Optional del cual crear el NullSafe
     * @param <T> el tipo del valor
     * @return una nueva instancia de NullSafe
     */
    public static <T> NullSafe<T> fromOptional(Optional<T> optional) {
        return optional != null ? new NullSafe<>(optional.orElse(null)) : NullSafe.empty();
    }

    /**
     * Permite mapear internamente el valor como Optional<T>, útil para
     * integración.
     *
     * @param mapper función que opera sobre Optional<T>
     * @param <R> tipo del resultado
     * @return el resultado del mapeo
     */
    public <R> R optionalMap(Function<Optional<T>, R> mapper) {
        return mapper.apply(toOptional());
    }

    /**
     * Aplica un adaptador funcional a este NullSafe.
     *
     * @param adapter el adaptador a aplicar
     * @param <R> el tipo del resultado
     * @return el resultado del adaptador
     */
    public <R> NullSafe<R> adapt(NullSafeAdapter<T, R> adapter) {
        return adapter.apply(this);
    }

    /**
     * Ejecuta una acción consumidora si el valor está presente y devuelve este
     * mismo objeto.
     *
     * @param action acción a ejecutar
     * @return this para encadenamiento
     */
    public NullSafe<T> peek(Consumer<? super T> action) {
        if (isPresent()) {
            action.accept(value);
        }
        return this;
    }

    public NullSafe<T> ifPresentOrElse(Consumer<? super T> presentAction, Runnable emptyAction) {
        if (isPresent()) {
            presentAction.accept(value);
        } else {
            emptyAction.run();
        }
        return this;
    }

    public NullSafe<T> recover(Function<Throwable, T> recoveryFunction) {
        if (isPresent()) {
            return this;
        }
        try {
            return NullSafe.of(recoveryFunction.apply(new NullPointerException()));
        } catch (Exception e) {
            return NullSafe.empty();
        }
    }

    public NullSafe<T> recoverWith(Function<Throwable, NullSafe<T>> recoveryFunction) {
        if (isPresent()) {
            return this;
        }
        try {
            return recoveryFunction.apply(new NullPointerException());
        } catch (Exception e) {
            return NullSafe.empty();
        }
    }

    public NullSafe<T> validate(Predicate<T> condition, String errorMessage) {
        if (isPresent() && !condition.test(value)) {
            throw new IllegalStateException(errorMessage);
        }
        return this;
    }

    @SuppressWarnings("unchecked")
    public <R> NullSafe<R> as(Class<R> type) {
        if (type.isInstance(value)) {
            return NullSafe.of(type.cast(value));
        }
        return NullSafe.empty();
    }

    public Stream<T> stream() {
        return isPresent() ? Stream.of(value) : Stream.empty();
    }

    public static <A, B, R> NullSafe<R> combine(
            NullSafe<A> a,
            NullSafe<B> b,
            BiFunction<A, B, R> combiner) {
        return a.flatMap(av -> b.map(bv -> combiner.apply(av, bv)));
    }

    public NullSafe<T> logIfPresent(String message) {
        if (isPresent()) {
            System.out.printf(message + ": %s%n", value);
        }
        return this;
    }

    public NullSafe<T> logIfAbsent(String message) {
        if (isEmpty()) {
            System.out.println(message);
        }
        return this;
    }

    /**
     * Convierte este NullSafe en un Result.
     *
     * @param error el valor del error a usar si el valor es null
     * @param <E> el tipo del error
     * @return un Result.Success si hay valor, o Result.Failure si es null
     */
    public <E> Result<T, E> toResult(E error) {
        return isPresent() ? Result.success(value) : Result.failure(error);
    }

    /**
     * Convierte este NullSafe en un Result usando un proveedor de error.
     *
     * @param errorSupplier el proveedor del valor de error
     * @param <E> el tipo del error
     * @return un Result.Success si hay valor, o Result.Failure si es null
     */
    public <E> Result<T, E> toResult(Supplier<E> errorSupplier) {
        return isPresent() ? Result.success(value) : Result.failure(errorSupplier.get());
    }
}
