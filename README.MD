# NullSafe - Manejo Seguro de Valores Nulos en Java

[![Build Status](https://img.shields.io/badge/build-passing-brightgreen)](https://github.com/yasmramos/nullsafe) 
[![License](https://img.shields.io/github/license/tu-usuario/nullsafe)](https://github.com/yasmramos/nullsafe) 
[![GitHub stars](https://img.shields.io/github/stars/tu-usuario/nullsafe?style=social)](https://github.com/yasmramos/nullsafe)

> Una alternativa mÃ¡s potente que `Optional<T>` para manejar valores nulos de forma segura, limpia y funcional en Java.

---

## ğŸ“Œ Â¿QuÃ© es NullSafe? 

`NullSafe<T>` es una clase diseÃ±ada para encapsular valores que pueden ser `null`, ofreciendo mÃ©todos encadenables, validaciones, recuperaciÃ³n de errores, adaptadores funcionales y soporte para colecciones, mapas y cadenas.

Evita los temidos `NullPointerException` y ofrece una API rica y flexible para desarrollar cÃ³digo limpio, seguro y expresivo.

---

## âœ¨ CaracterÃ­sticas Destacadas

| CaracterÃ­stica | DescripciÃ³n |
|----------------|-------------|
| âœ… Encadenamiento funcional | MÃ©todos como `map`, `flatMap`, `filter`, etc. |
| âœ… RecuperaciÃ³n de fallos | `.recover(...)`, `.recoverWith(...)` |
| âœ… Validaciones integradas | `.validate(pred, msg)`, `.validate(pred, () -> ex)` |
| âœ… ConversiÃ³n a tipos | `.toOptional()`, `.toResult("error")`, `.stream()` |
| âœ… Adaptadores personalizados | `.adapt(adapter)` |
| âœ… Logging integrado | `.logIfPresent(...)`, `.logIfAbsent(...)` |
| âœ… CombinaciÃ³n de mÃºltiples valores | `.combine(a, b, (x, y) -> x + y)` |
| âœ… Uso en colecciones y mapas | MÃ©todos estÃ¡ticos como `filterNonNull(...)`, `mapNonNullValues(...)` |
| âœ… Tipos primitivos especializados | `NullSafeInt`, `NullSafeLong`, `NullSafeDouble`, `NullSafeFloat`, `NullSafeBoolean`, `NullSafeByte`, `NullSafeShort` |

---

## ğŸ’¡ Ejemplo RÃ¡pido

```java
NullSafe.of("   hola mundo   ")
        .map(String::trim)
        .filter(s -> s.length() > 5)
        .map(String::toUpperCase)
        .recover(ex -> "VALOR POR DEFECTO")
        .validate(s -> s.contains("HOLA"), "No contiene 'HOLA'")
        .ifPresent(System.out::println);
```

## ğŸ§© IntegraciÃ³n con Result<T, E> 

Puedes convertir fÃ¡cilmente entre NullSafe<T> y Result<T, E>:

```java
 
Result<String, String> result = NullSafe.of("valor").toResult("Valor no encontrado");

result.ifSuccess(System.out::println)
       .ifFailure(err -> System.err.println("Error: " + err));
```

## ğŸ”¢ Tipos Primitivos NullSafe

AdemÃ¡s de `NullSafe<T>`, la librerÃ­a incluye clases especializadas para manejar tipos primitivos de forma segura:

- **`NullSafeInt`** - Manejo seguro de valores `Integer`
- **`NullSafeLong`** - Manejo seguro de valores `Long`
- **`NullSafeDouble`** - Manejo seguro de valores `Double`
- **`NullSafeFloat`** - Manejo seguro de valores `Float`
- **`NullSafeBoolean`** - Manejo seguro de valores `Boolean`
- **`NullSafeByte`** - Manejo seguro de valores `Byte`
- **`NullSafeShort`** - Manejo seguro de valores `Short`

### Ejemplos de Uso con Tipos Primitivos

```java
// NullSafeInt
int result = NullSafeInt.of(42)
    .ifPresent(value -> System.out.println("Valor: " + value))
    .orElse(0);

// NullSafeDouble con validaciones
double price = NullSafeDouble.of(product.getPrice())
    .validate(p -> p > 0, "El precio debe ser positivo")
    .orElse(0.0);

// NullSafeBoolean para lÃ³gica condicional
boolean isValid = NullSafeBoolean.of(userInput)
    .orElse(false);

// Manejo de valores extremos
NullSafeLong.of(Long.MAX_VALUE)
    .orElseThrow(() -> new RuntimeException("Valor muy grande"));

NullSafeDouble.of(Double.NaN)
    .ifPresent(value -> System.out.println("Es NaN: " + value))
    .orElseGet(() -> 0.0);
```

### Ventajas de los Tipos Primitivos

- **Rendimiento**: Evitan el boxing/unboxing automÃ¡tico
- **Memoria**: Menor uso de memoria que los tipos boxing
- **Seguridad**: Misma protecciÃ³n contra `NullPointerException`
- **Consistencia**: Misma API que `NullSafe<T>` pero optimizada para primitivos
---

## ğŸ“¦ InstalaciÃ³n

---

## ğŸ§ª Pruebas Unitarias

Todas las funciones estÃ¡n cubiertas por pruebas unitarias usando JUnit 5 . Puedes ejecutarlas asÃ­:

```bash 
   mvn test
   ```

O si usas Gradle:

```bash
   gradle test
```
---

## ğŸ“Š Cobertura de CÃ³digo

Soporta anÃ¡lisis de cobertura con JaCoCo :

```bash
   mvn clean test jacoco:report
```
El informe se genera en:
```text
   target/site/jacoco/index.html
```
---

## ğŸ§± Contribuir

Â¡Estamos abiertos a contribuciones! Si quieres mejorar la librerÃ­a, corrige errores, aÃ±adir nuevas funciones o traducir documentaciÃ³n, Â¡adelante! 

   1. Abre un issue
   2. Haz un fork
   3. Crea una nueva rama (git checkout -b feature/foo)
   4. Haz commit de tus cambios (git commit -m 'Add some foo')
   5. Sube los cambios (git push origin feature/foo)
   6. Crea un pull request


---

## ğŸ“„ Licencia

Este proyecto estÃ¡ bajo la Licencia MIT .

Â© 2025 yasmramos / Comunidad Java.

---

## ğŸ“¬ Contacto

Si tienes dudas, sugerencias o quieres colaborar: 

    ğŸ“§ Email: yasmramos95@gmail.com 
    ğŸ™ GitHub: @yasmramos 
     